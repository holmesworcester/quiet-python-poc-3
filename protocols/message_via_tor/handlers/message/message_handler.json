{
  "type": "message",
  "projector": {
    "description": "Validates sig using metadata, adds to state.messages if valid; if selfGenerated, encrypts and adds to outgoing.",
    "func": "projector.project",
    "tests": [
      {
        "given": {
          "db": {"state": {"messages": []}},
          "envelope": {
            "data": {"type": "message", "text": "Hello", "sender": "alice_pub", "sig": "abc"},
            "metadata": {"selfGenerated": true, "received_by": "alice_pub"}
          }
        },
        "then": {
          "db": {
            "state": {"messages": [{"text": "Hello", "sender": "alice_pub", "timestamp": "*", "received_by": "alice_pub"}]}
          }
        }
      },
      {
        "given": {
          "db": {"state": {"peers": [{"pubkey": "sender1", "name": "Sender 1", "received_by": "test_identity"}], "messages": [], "identities": [{"pubkey": "test_identity", "privkey": "test_privkey", "name": "Test Identity"}]}},
          "envelope": {
            "data": {"type": "message", "text": "World", "sender": "sender1", "sig": "def"},
            "metadata": {"eventId": "event123", "received_by": "test_identity"}
          }
        },
        "then": {
          "db": {
            "eventStore": [{"type": "message", "text": "World", "sender": "sender1", "sig": "def"}],
            "state": {"messages": [{"text": "World", "sender": "sender1", "sig": "def", "id": "event123", "received_by": "test_identity"}]}
          }
        }
      },
      {
        "description": "Message from unknown sender (no peers) should be stored with unknown_peer flag",
        "given": {
          "db": {"state": {"peers": [], "messages": []}},
          "envelope": {
            "data": {"type": "message", "text": "Unknown", "sender": "unknown_sender"},
            "metadata": {}
          }
        },
        "then": {
          "db": {
            "eventStore": [{"type": "message", "text": "Unknown", "sender": "unknown_sender"}],
            "state": {"messages": [{"text": "Unknown", "sender": "unknown_sender", "timestamp": "*", "unknown_peer": true}]}
          }
        }
      },
      {
        "description": "Self-generated message with recipient should be stored with received_by set to sender",
        "given": {
          "db": { "state": { "messages": [] } },
          "envelope": {
            "data": { "type": "message", "text": "Hello", "sender": "peerA", "recipient": "peerB", "sig": "abc" },
            "metadata": { "selfGenerated": true }
          }
        },
        "then": {
          "db": {
            "state": {
              "messages": [ { "text": "Hello", "sender": "peerA", "recipient": "peerB", "received_by": "peerA", "timestamp": "*" } ]
            }
          }
        }
      },
      {
        "description": "Projector should preserve recipient on stored messages (with known sender)",
        "given": {
          "db": { "state": { "messages": [], "peers": [{"pubkey": "peerA", "name": "Peer A", "received_by": "peerB"}], "identities": [{"pubkey": "peerB", "privkey": "peerB_priv", "name": "Peer B"}] } },
          "envelope": {
            "data": { "type": "message", "text": "Hi", "sender": "peerA", "recipient": "peerB", "sig": "def" },
            "metadata": {"received_by": "peerB"}
          }
        },
        "then": {
          "db": {
            "state": {
              "messages": [ { "text": "Hi", "sender": "peerA", "recipient": "peerB", "timestamp": "*", "received_by": "peerB" } ]
            }
          }
        }
      },
      {
        "description": "Projector should ignore messages lacking text/content (with known sender)",
        "given": {
          "db": { "state": { "messages": [], "peers": [{"pubkey": "peerA", "name": "Peer A", "received_by": "peerB"}] } },
          "envelope": {
            "data": { "type": "message", "sender": "peerA" },
            "metadata": {"received_by": "peerB"}
          }
        },
        "then": {
          "db": {
            "state": { "messages": [] }
          }
        }
      },
      {
        "description": "Projector should not add to outgoing for non-self-generated messages (with known sender)",
        "given": {
          "db": { "state": { "messages": [], "outgoing": [], "peers": [{"pubkey": "peerA", "name": "Peer A", "received_by": "peerB"}], "identities": [{"pubkey": "peerB", "privkey": "peerB_priv", "name": "Peer B"}] } },
          "envelope": {
            "data": { "type": "message", "text": "External", "sender": "peerA", "recipient": "peerB", "sig": "xyz" },
            "metadata": { "selfGenerated": false, "received_by": "peerB" }
          }
        },
        "then": {
          "db": {
            "state": {
              "messages": [ { "text": "External", "sender": "peerA", "recipient": "peerB", "timestamp": "*", "received_by": "peerB" } ],
              "outgoing": []
            }
          }
        }
      },
      {
        "description": "Message from unknown peer should be marked as unknown-peer",
        "given": {
          "db": { "state": { "messages": [], "peers": [] } },
          "envelope": {
            "data": { "type": "message", "text": "Hello from unknown", "sender": "unknown_pub", "sig": "xyz" },
            "metadata": {}
          }
        },
        "then": {
          "db": {
            "eventStore": [{ "type": "message", "text": "Hello from unknown", "sender": "unknown_pub", "sig": "xyz" }],
            "state": { 
              "messages": [{ 
                "text": "Hello from unknown", 
                "sender": "unknown_pub", 
                "sig": "xyz", 
                "timestamp": "*",
                "unknown_peer": true 
              }],
              "peers": []
            }
          }
        }
      },
      {
        "description": "Message from known peer should not be marked as unknown-peer",
        "given": {
          "db": { 
            "state": { 
              "messages": [], 
              "peers": [{ "pubkey": "known_pub", "name": "Known Peer", "received_by": "test_identity" }],
              "identities": [{"pubkey": "test_identity", "privkey": "test_privkey", "name": "Test Identity"}]
            } 
          },
          "envelope": {
            "data": { "type": "message", "text": "Hello from known", "sender": "known_pub", "sig": "abc" },
            "metadata": {"received_by": "test_identity"}
          }
        },
        "then": {
          "db": {
            "eventStore": [{ "type": "message", "text": "Hello from known", "sender": "known_pub", "sig": "abc" }],
            "state": { 
              "messages": [{ 
                "text": "Hello from known", 
                "sender": "known_pub", 
                "sig": "abc", 
                "timestamp": "*",
                "received_by": "test_identity"
              }]
            }
          }
        }
      },
      {
        "description": "Message should be marked as unknown_peer when sender is not known to the specific recipient",
        "given": {
          "db": { 
            "state": { 
              "messages": [],
              "peers": [
                { "pubkey": "peer1", "name": "Peer 1", "received_by": "identity1" },
                { "pubkey": "peer2", "name": "Peer 2", "received_by": "identity2" }
              ],
              "identities": [
                {"pubkey": "identity1", "privkey": "priv1", "name": "Identity 1"},
                {"pubkey": "identity2", "privkey": "priv2", "name": "Identity 2"}
              ]
            } 
          },
          "envelope": {
            "data": { "type": "message", "text": "Hello from peer1", "sender": "peer1", "sig": "xyz" },
            "metadata": {"received_by": "identity2"}
          }
        },
        "then": {
          "db": {
            "eventStore": [{ "type": "message", "text": "Hello from peer1", "sender": "peer1", "sig": "xyz" }],
            "state": { 
              "messages": [{ 
                "text": "Hello from peer1", 
                "sender": "peer1", 
                "sig": "xyz", 
                "timestamp": "*",
                "received_by": "identity2",
                "unknown_peer": true
              }]
            }
          }
        }
      }
    ]
  },
  "commands": {
    "create": {
      "description": "Creates canonical signed event; puts in outgoing if recipient specified.",
      "func": "create.execute",
      "tests": [
        {
          "given": {"db": {}, "params": {"text": "Hello"}},
          "then": {"return": {"return": "Created", "newEvents": [{"type": "message", "text": "Hello", "sig": "*"}]}}
        },
        {
          "given": {"db": {"state": {}}, "params": {"text": "Hello peer", "recipient": "peer123"}},
          "then": {
            "return": {"return": "Message sent to outgoing", "newEvents": [{"type": "message", "text": "Hello peer", "recipient": "peer123", "sig": "*"}]},
            "db": {
              "state": {
                "outgoing": [
                  {
                    "recipient": "peer123",
                    "data": {"type": "message", "text": "Hello peer", "recipient": "peer123", "sig": "*"}
                  }
                ]
              }
            }
          }
        },
        {
          "description": "Message sent to recipient is delivered after ticks", 
          "given": {
            "db": {
              "state": {
                "identities": {
                  "alice": {
                    "keypair": {
                      "public": "alice_pub",
                      "private": "alice_priv"
                    },
                    "name": "Alice"
                  }
                },
                "peers": [{"pubkey": "alice_pub", "name": "Alice"}],
                "messages": []
              }
            },
            "params": {
              "text": "Hello via ticks",
              "recipient": "bob_pub",
              "time_now_ms": 1000
            },
            "identity": "alice"
          },
          "ticks": 2,
          "then": {
            "return": {
              "return": "Message sent to outgoing"
            },
            "db": {
              "state": {
                "messages": [{
                  "text": "Hello via ticks",
                  "sender": "*",
                  "recipient": "bob_pub"
                }],
                "outgoing": []
              }
            }
          }
        }
      ]
    },
    "list": {
      "description": "Lists all messages for a given peer",
      "func": "list.execute",
      "tests": [
        {
          "given": {
            "db": {
              "state": {
                "messages": [
                  {"text": "Hi", "sender": "peer1", "recipient": "peer2", "timestamp": 100, "received_by": "peer1"},
                  {"text": "Hello", "sender": "peer2", "recipient": "peer1", "timestamp": 200, "received_by": "peer1"}
                ]
              }
            },
            "params": {"peer_pubkey": "peer1"}
          },
          "then": {
            "return": {
              "return": "Found 2 messages",
              "messages": [
                {"text": "Hi", "sender": "peer1", "recipient": "peer2", "timestamp": 100},
                {"text": "Hello", "sender": "peer2", "recipient": "peer1", "timestamp": 200}
              ]
            }
          }
        },
        {
          "description": "List should exclude messages marked as unknown_peer",
          "given": {
            "db": {
              "state": {
                "messages": [
                  {"text": "Hi", "sender": "peer1", "recipient": "peer2", "timestamp": 100, "received_by": "peer1"},
                  {"text": "Unknown message", "sender": "unknown1", "recipient": "peer1", "timestamp": 150, "unknown_peer": true, "received_by": "peer1"},
                  {"text": "Hello", "sender": "peer2", "recipient": "peer1", "timestamp": 200, "received_by": "peer1"}
                ]
              }
            },
            "params": {"peer_pubkey": "peer1"}
          },
          "then": {
            "return": {
              "return": "Found 2 messages",
              "messages": [
                {"text": "Hi", "sender": "peer1", "recipient": "peer2", "timestamp": 100},
                {"text": "Hello", "sender": "peer2", "recipient": "peer1", "timestamp": 200}
              ]
            }
          }
        }
      ]
    }
  }
}