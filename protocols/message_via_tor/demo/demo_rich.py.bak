#!/usr/bin/env python3
"""
Simple terminal demo for message_via_tor protocol.
Shows two identities side-by-side with Redux-like state inspection.
"""

import json
import os
import sys
import copy
from pathlib import Path
from rich.console import Console
from rich.layout import Layout
from rich.panel import Panel
from rich.text import Text
from rich.live import Live
from rich.table import Table
from rich import box
import threading
import time

# Add the root directory to path for core imports
sys.path.insert(0, str(Path(__file__).parent.parent.parent.parent))
from core.api import execute_api


class ProtocolState:
    def __init__(self):
        # Persistent state that survives API calls
        self.db = {
            'state': {
                'identities': [],
                'peers': [],
                'messages': [],
                'outgoing': []
            },
            'eventStore': []
        }
        self.state_changes = []
        self.selected_change = None
    
    def reset(self):
        self.db = {
            'state': {
                'identities': [],
                'peers': [],
                'messages': [],
                'outgoing': []
            },
            'eventStore': []
        }
        self.state_changes = []
        self.selected_change = None
    
    def record_change(self, operation, before_state, after_state):
        change = {
            'operation': operation,
            'before': copy.deepcopy(before_state),
            'after': copy.deepcopy(after_state),
            'timestamp': time.time()
        }
        self.state_changes.append(change)
        return len(self.state_changes) - 1


class TestLoader:
    def __init__(self):
        self.tests = []
        self.load_tests()
    
    def load_tests(self):
        handlers_dir = Path(__file__).parent.parent / "handlers"
        for handler_file in handlers_dir.glob("*/*_handler.json"):
            try:
                with open(handler_file) as f:
                    handler_data = json.load(f)
                
                # Load projector tests
                projector = handler_data.get("projector", {})
                if "tests" in projector:
                    for test in projector["tests"]:
                        self.tests.append({
                            "name": f"{handler_file.parent.name}.projector: {test.get('description', 'No description')}",
                            "given": test.get("given", {}),
                            "type": "projector"
                        })
                
                # Load command tests
                commands = handler_data.get("commands", {})
                for cmd_name, cmd_data in commands.items():
                    if "tests" in cmd_data:
                        for test in cmd_data["tests"]:
                            self.tests.append({
                                "name": f"{handler_file.parent.name}.{cmd_name}: {test.get('description', 'No description')}",
                                "given": test.get("given", {}),
                                "type": "command"
                            })
            except Exception as e:
                print(f"Error loading {handler_file}: {e}")


class DemoApp:
    def __init__(self):
        self.console = Console()
        self.state = ProtocolState()
        self.test_loader = TestLoader()
        self.selected_test = self.find_good_default_test()
        self.identity1_selected = 0
        self.identity2_selected = 0
        self.message1_input = ""
        self.message2_input = ""
        self.active_input = None  # 1 or 2 for which message input is active
        self.selected_change = None  # Index of selected state change for inspection
        self.running = True
        
        # Auto-load the default test
        if self.selected_test > 0:
            self.load_test()
    
    def find_good_default_test(self):
        """Find a good test with multiple peers/identities"""
        # Test 12 is "Message broadcast to peers is delivered after ticks" - has Alice, Bob, Charlie
        return 12
    
    def get_identities(self):
        """Get list of identities from current state"""
        identities = []
        state = self.state.db.get('state', {})
        
        # Handle both dict and list formats
        identity_data = state.get('identities', [])
        if isinstance(identity_data, dict):
            for key, value in identity_data.items():
                identities.append({
                    'id': key,
                    'name': value.get('name', key),
                    'pubkey': value.get('keypair', {}).get('public', key)
                })
        elif isinstance(identity_data, list):
            for item in identity_data:
                identities.append({
                    'id': item.get('pubkey', 'unknown'),
                    'name': item.get('name', 'Unknown'),
                    'pubkey': item.get('pubkey', 'unknown')
                })
        
        return identities
    
    def get_messages_for_identity(self, identity_pubkey):
        """Get messages visible to a specific identity"""
        messages = self.state.db.get('state', {}).get('messages', [])
        identity_messages = []
        
        for msg in messages:
            # Show messages received by this identity or sent by this identity
            if (msg.get('received_by') == identity_pubkey or 
                msg.get('sender') == identity_pubkey):
                # Skip unknown peer messages
                if not msg.get('unknown_peer', False):
                    identity_messages.append(msg)
        
        return identity_messages
    
    def create_test_panel(self):
        """Create the test selector panel"""
        # Get actual terminal height from console
        available_height = max(10, self.console.height - 15)  # Reserve space for layout
        
        content = []
        
        # Calculate visible range around selected test
        start_idx = max(0, self.selected_test - available_height // 2)
        end_idx = min(len(self.test_loader.tests), start_idx + available_height - 3)
        
        if end_idx - start_idx < available_height - 3:
            start_idx = max(0, end_idx - (available_height - 3))
        
        for i in range(start_idx, end_idx):
            if i >= len(self.test_loader.tests):
                break
            test = self.test_loader.tests[i]
            marker = "> " if i == self.selected_test else "• "
            content.append(f"{marker}{test['name'][:35]}")
        
        # Add scrolling indicator
        if start_idx > 0:
            content.insert(0, "↑ (more above)")
        if end_idx < len(self.test_loader.tests):
            content.append("↓ (more below)")
        
        content.append("")
        content.append("[Space: Load] [R: Reset]")
        
        return Panel(
            "\n".join(content),
            title=f"Tests ({self.selected_test + 1}/{len(self.test_loader.tests)})",
            box=box.ROUNDED
        )
    
    def create_identity_panel(self, identity_num):
        """Create panel for identity 1 or 2"""
        available_height = max(10, self.console.height - 15)  # Use actual terminal height
        
        identities = self.get_identities()
        
        if identity_num == 1:
            selected_idx = self.identity1_selected
            message_input = self.message1_input
        else:
            selected_idx = self.identity2_selected
            message_input = self.message2_input
        
        # Identity dropdown
        if identities:
            if selected_idx >= len(identities):
                selected_idx = 0
            selected_identity = identities[selected_idx]
            name_short = selected_identity['name'][:10]
            dropdown_text = f"┌─ {name_short} ──▼──┐\n└" + "─" * (len(name_short) + 8) + "┘"
        else:
            dropdown_text = "┌─ No IDs ──▼──┐\n└─────────────┘"
            selected_identity = None
        
        content = [dropdown_text, ""]
        
        # Messages (scrollable)
        if selected_identity:
            messages = self.get_messages_for_identity(selected_identity['pubkey'])
            msg_lines = available_height - 6  # Reserve space for dropdown and input
            
            for msg in messages[-msg_lines:]:  # Show recent messages that fit
                sender_name = msg.get('sender', 'Unknown')[:15]
                text = msg.get('text', '')
                content.append(f"{sender_name}: {text}")
            
            # Show scroll indicator if there are more messages
            if len(messages) > msg_lines:
                content.insert(2, f"↑ ({len(messages) - msg_lines} more)")
        
        # No padding needed
        
        # Message input (always at bottom)
        input_marker = ">" if self.active_input == identity_num else " "
        input_display = message_input + ('_' if self.active_input == identity_num else '')
        content.append(f"{input_marker}[{input_display}]")
        
        return Panel(
            "\n".join(content),
            title=f"Identity {identity_num}",
            box=box.ROUNDED
        )
    
    def create_state_changes_panel(self):
        """Create the state changes log panel"""
        available_height = max(10, self.console.height - 15)
        
        content = []
        if self.state.state_changes:
            # Show recent changes that fit in the panel
            visible_changes = self.state.state_changes[-(available_height - 2):]
            
            for i, change in enumerate(visible_changes):
                actual_index = len(self.state.state_changes) - len(visible_changes) + i
                marker = "> " if actual_index == self.selected_change else "  "
                op_text = change['operation']
                content.append(f"{marker}{op_text}")
            
            # Show scroll indicator if there are more changes
            if len(self.state.state_changes) > available_height - 2:
                content.insert(0, f"↑ ({len(self.state.state_changes) - (available_height - 2)} more)")
        else:
            content.append("No changes yet")
        
        return Panel(
            "\n".join(content),
            title=f"State Changes ({len(self.state.state_changes)})",
            box=box.ROUNDED
        )
    
    def create_state_inspector_panel(self):
        """Create the state inspector panel"""
        available_height = max(10, self.console.height - 15)
        
        content = []
        
        if self.selected_change is not None and self.selected_change < len(self.state.state_changes):
            change = self.state.state_changes[self.selected_change]
            
            # Calculate space for before/after sections
            section_lines = (available_height - 4) // 2  # Reserve space for headers
            
            content.append("BEFORE:")
            if change['before']:
                before_json = json.dumps(change['before'], indent=2)
                before_lines = before_json.split('\n')[:section_lines]
                content.extend(before_lines)  # Don't truncate
            else:
                content.append("(empty)")
            
            content.append("")
            content.append("AFTER:")
            if change['after']:
                after_json = json.dumps(change['after'], indent=2)
                after_lines = after_json.split('\n')[:section_lines]
                content.extend(after_lines)  # Don't truncate
            else:
                content.append("(empty)")
                
        else:
            content = ["Select a state change", "from the log to", "inspect its", "before/after states"]
        
        # No padding needed
        
        return Panel(
            "\n".join(content),
            title="State Inspector",
            box=box.ROUNDED
        )
    
    def create_layout(self):
        """Create the main layout"""
        layout = Layout()
        
        # Split into main content and footer, using size instead of ratio
        layout.split_column(
            Layout(name="main"),
            Layout(Panel(
                "[Space: Load] [R: Reset] [T: Tick] [I: Create ID] [1/2: Input] [←→: Inspect] [Q: Quit]",
                box=box.ROUNDED
            ), name="footer", size=3)
        )
        
        # Split main into 5 columns
        layout["main"].split_row(
            Layout(self.create_test_panel(), name="tests", ratio=3),
            Layout(self.create_identity_panel(1), name="identity1", ratio=2),
            Layout(self.create_identity_panel(2), name="identity2", ratio=2), 
            Layout(self.create_state_changes_panel(), name="changes", ratio=2),
            Layout(self.create_state_inspector_panel(), name="inspector", ratio=3)
        )
        
        return layout
    
    def load_test(self):
        """Load the selected test state"""
        if 0 <= self.selected_test < len(self.test_loader.tests):
            test = self.test_loader.tests[self.selected_test]
            given = test.get('given', {})
            
            before_state = copy.deepcopy(self.state.db.get('state', {}))
            
            # Load test state
            if 'db' in given:
                self.state.db = copy.deepcopy(given['db'])
            
            after_state = copy.deepcopy(self.state.db.get('state', {}))
            self.state.record_change(f"load_test: {test['name'][:30]}", before_state, after_state)
    
    def create_identity(self, name=""):
        """Create a new identity using the API"""
        before_state = copy.deepcopy(self.state.db.get('state', {}))
        
        try:
            response = execute_api(
                "message_via_tor",
                "POST",
                "/identities",
                data={
                    "name": name if name else f"User{len(self.get_identities())+1}",
                    "db": self.state.db
                }
            )
            
            if response.get("status") == 201:
                # Update our persistent state
                self.state.db = response["body"]["db"]
                after_state = copy.deepcopy(self.state.db.get('state', {}))
                self.state.record_change("identity.create", before_state, after_state)
            
        except Exception as e:
            self.state.record_change(f"identity.create ERROR: {str(e)}", before_state, before_state)
    
    def send_message(self, identity_num):
        """Send message from specified identity"""
        identities = self.get_identities()
        
        if identity_num == 1:
            selected_idx = self.identity1_selected
            message_text = self.message1_input
            self.message1_input = ""
        else:
            selected_idx = self.identity2_selected
            message_text = self.message2_input
            self.message2_input = ""
        
        if not message_text.strip() or not identities:
            return
        
        if selected_idx >= len(identities):
            return
        
        selected_identity = identities[selected_idx]
        
        before_state = copy.deepcopy(self.state.db.get('state', {}))
        
        try:
            response = execute_api(
                "message_via_tor",
                "POST", 
                "/messages",
                data={
                    "text": message_text.strip(),
                    "db": self.state.db
                },
                identity=selected_identity['id']
            )
            
            if response.get("status") == 201:
                # Update our persistent state  
                self.state.db = response["body"]["db"]
                after_state = copy.deepcopy(self.state.db.get('state', {}))
                self.state.record_change(f"message.create: {message_text[:20]}", before_state, after_state)
            
        except Exception as e:
            self.state.record_change(f"message.create ERROR: {str(e)}", before_state, before_state)
    
    def tick(self):
        """Run one tick cycle"""
        before_state = copy.deepcopy(self.state.db.get('state', {}))
        
        try:
            response = execute_api(
                "message_via_tor",
                "POST",
                "/tick",
                data={"db": self.state.db}
            )
            
            if response.get("status") == 200:
                # Update our persistent state
                self.state.db = response["body"]["db"]
                after_state = copy.deepcopy(self.state.db.get('state', {}))
                self.state.record_change("tick", before_state, after_state)
            
        except Exception as e:
            self.state.record_change(f"tick ERROR: {str(e)}", before_state, before_state)
    
    def handle_key(self, key):
        """Handle keyboard input"""
        if key == 'q':
            self.running = False
        elif key == ' ':  # Space
            self.load_test()
        elif key == 'r':
            before_state = copy.deepcopy(self.state.db.get('state', {}))
            self.state.reset()
            after_state = {}
            self.state.record_change("reset", before_state, after_state)
        elif key == 't':
            self.tick()
        elif key == 'i':
            self.create_identity()
        elif key == '1':
            self.active_input = 1
        elif key == '2':
            self.active_input = 2
        elif key == 'up':
            if self.selected_test > 0:
                self.selected_test -= 1
        elif key == 'down':
            if self.selected_test < len(self.test_loader.tests) - 1:
                self.selected_test += 1
        elif key == 'left':
            # Navigate state changes
            if self.state.state_changes and (self.selected_change is None or self.selected_change > 0):
                self.selected_change = (self.selected_change or len(self.state.state_changes)) - 1
        elif key == 'right':
            # Navigate state changes
            if self.state.state_changes and (self.selected_change is None or self.selected_change < len(self.state.state_changes) - 1):
                self.selected_change = (self.selected_change or -1) + 1
        elif key == 'enter' and self.active_input:
            self.send_message(self.active_input)
        elif key and self.active_input and len(key) == 1 and key.isprintable():
            # Add character to active input
            if self.active_input == 1:
                self.message1_input += key
            else:
                self.message2_input += key
        elif key == 'backspace' and self.active_input:
            # Remove character from active input
            if self.active_input == 1 and self.message1_input:
                self.message1_input = self.message1_input[:-1]
            elif self.active_input == 2 and self.message2_input:
                self.message2_input = self.message2_input[:-1]
    
    def run(self):
        """Run the demo application"""
        import termios, tty, select
        
        # Use Live for smooth updates with height constraint
        with Live(self.create_layout(), console=self.console, screen=False, refresh_per_second=10) as live:
            old_settings = termios.tcgetattr(sys.stdin)
            try:
                tty.setraw(sys.stdin.fileno())
                
                while self.running:
                    # Non-blocking input check
                    if select.select([sys.stdin], [], [], 0.1)[0]:
                        char = sys.stdin.read(1)
                        
                        # Convert special keys
                        if char == '\x1b':  # ESC sequence
                            # Read the rest of the escape sequence
                            if select.select([sys.stdin], [], [], 0.1)[0]:
                                char += sys.stdin.read(1)
                                if select.select([sys.stdin], [], [], 0.1)[0]:
                                    char += sys.stdin.read(1)
                            
                            if char == '\x1b[A':
                                self.handle_key('up')
                            elif char == '\x1b[B':
                                self.handle_key('down')
                            elif char == '\x1b[C':
                                self.handle_key('right')
                            elif char == '\x1b[D':
                                self.handle_key('left')
                            else:
                                continue
                        elif char == '\r' or char == '\n':
                            self.handle_key('enter')
                        elif char == '\x7f' or char == '\x08':  # Backspace or Delete
                            self.handle_key('backspace')
                        elif char == '\x03':  # Ctrl+C
                            break
                        elif ord(char) >= 32:  # Printable characters
                            self.handle_key(char)
                        else:
                            continue
                        
                        # Update display
                        live.update(self.create_layout())
            
            finally:
                # Restore terminal settings
                termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)


if __name__ == "__main__":
    app = DemoApp()
    app.run()