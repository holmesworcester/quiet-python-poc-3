# ============================================================================
# Cryptographic Handler Test Configuration
# ============================================================================
# Purpose: Tests for cryptographic operations including signing/verification,
#          encryption/decryption, hashing, sealing/unsealing, and key derivation.
#
# Modes:
# - dummy: Deterministic mock crypto for testing (predictable outputs)
# - real: Actual cryptographic operations using NaCl/libsodium
#
# This handler demonstrates proper crypto testing with both modes to ensure
# consistent behavior across development and production environments.
# ============================================================================

# Common anchors for reused data
anchors:
  # Environment settings
  cryptoDummy: &cryptoDummy
    CRYPTO_MODE: dummy
  cryptoReal: &cryptoReal
    CRYPTO_MODE: real
  
  # Common test data
  testUser: &testUser test-user
  emptyDb: &emptyDb {}
  
  # Common schema properties
  stringRequired: &stringRequired
    type: string
  stringPattern64Hex: &stringPattern64Hex
    type: string
    pattern: ^[a-f0-9]{64}$
  stringPattern128Hex: &stringPattern128Hex
    type: string
    pattern: ^[a-f0-9]{128}$

jsonTestsOnly: true  # This handler only supports JSON-based testing

# ============================================================================
# Command Definitions
# ============================================================================
commands:
  # --------------------------------------------------------------------------
  # Sign and Verify Command
  # --------------------------------------------------------------------------
  # Tests digital signature creation and verification using Ed25519
  test_sign_verify:
    input:
      $schema: http://json-schema.org/draft-07/schema#
      type: object
      required:
        - data
      properties:
        data:
          type: string  # Data to be signed
    output:
      $schema: http://json-schema.org/draft-07/schema#
      type: object
      required:
        - signature
        - verified
        - publicKey
        - privateKey
      properties:
        signature:
          type: string    # Hex-encoded signature
        verified:
          type: boolean   # Verification result
        publicKey:
          type: string    # Hex-encoded public key
        privateKey:
          type: string    # Hex-encoded private key
    tests:
      # Dummy mode: predictable outputs for testing
      - description: Sign and verify data successfully (dummy mode)
        given:
          db: *emptyDb
          params:
            data: Hello, world!
          identity: *testUser  # User identity for key generation
          env: *cryptoDummy   # Use mock crypto
        then:
          return:
            # Dummy signature includes hash of data for predictability
            signature: dummy_sig_315f5bdb76d078c4
            verified: true
            publicKey: dummy_pubkey_test-user
            privateKey: dummy_privkey_test-user
      
      # Real crypto mode: actual Ed25519 signatures
      - description: Sign and verify data successfully (real crypto)
        given:
          db: *emptyDb
          params:
            data: Hello, world!
          identity: *testUser
          env: *cryptoReal    # Use real crypto
        then:
          return:
            # Real signature (128 hex chars for Ed25519)
            signature: e91aa4ca11816de9e3a543bbc66fa74a7c58869dee39b275c669767c241b9bc74e7cac6675920ab0be21072845119e1718686a21c8cfcda3a4017131856cb706
            verified: true
            # Real Ed25519 public key (compressed, 66 hex chars)
            publicKey: 02eb23efde706a6fb52ab3acfa3bec820dc95dc637fc96fd420cf265451de0ec
            # Real Ed25519 private key (64 hex chars)
            privateKey: a6fd3e8b44e698448f896ec0468f5462bb5edfe088df19bbab1e58db09b756d9

  # --------------------------------------------------------------------------
  # Encrypt and Decrypt Command
  # --------------------------------------------------------------------------
  # Tests symmetric encryption using NaCl SecretBox (XSalsa20-Poly1305)
  test_encrypt_decrypt:
    input:
      $schema: http://json-schema.org/draft-07/schema#
      type: object
      required:
        - data
      properties:
        data:
          type: string    # Plaintext to encrypt
        key:
          type: string    # Optional encryption key (hex)
    output:
      $schema: http://json-schema.org/draft-07/schema#
      type: object
      required:
        - encrypted
        - decrypted
        - matches
      properties:
        encrypted:
          type: object
          required:
            - ciphertext
            - nonce
            - algorithm
          properties:
            ciphertext:
              type: string    # Hex-encoded encrypted data
            nonce:
              type: string    # Hex-encoded nonce (24 bytes)
            algorithm:
              type: string    # Encryption algorithm used
        decrypted:
          type: string        # Decrypted plaintext
        matches:
          type: boolean       # Whether decrypted matches original
    tests:
      # Dummy mode: predictable encryption
      - description: Encrypt and decrypt data successfully (dummy mode)
        given:
          db: *emptyDb
          params:
            data: Secret message
          identity: *testUser
          env: *cryptoDummy
        then:
          return:
            encrypted:
              # Dummy ciphertext includes plaintext for debugging
              ciphertext: dummy_encrypted_Secret message
              nonce: dummy_nonce
              algorithm: dummy
            decrypted: Secret message
            matches: true
      
      # Real crypto with provided key
      - description: Encrypt and decrypt with provided key (real crypto)
        given:
          db: *emptyDb
          params:
            data: Secret message
            # 32-byte key for NaCl SecretBox (64 hex chars)
            key: c954d2c2ec1062592b701c8002d76bd4e23a1597cb45ad1fb4b5b27a913274ce
          identity: *testUser
          env: *cryptoReal
        then:
          return:
            encrypted:
              ciphertext: 8f4a2b1e3d9c7a6f5e4d3c2b1a0f9e8d7c6b5a4f3e2d1c0b
              # 24-byte nonce (48 hex chars)
              nonce: a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4
              algorithm: nacl_secretbox
            decrypted: Secret message
            matches: true
      
      # Test with special characters and longer message
      - description: Encrypt longer message with special characters
        given:
          db: *emptyDb
          params:
            data: 'This is a longer message with special characters: !@#$%^&*()'
            key: d6f8a3b2c1e9d7f5a4b3c2d1e0f9a8b7c6d5e4f3b2c1d0e9f8a7b6c5d4e3f2a1
          identity: *testUser
          env: *cryptoReal
        then:
          return:
            encrypted:
              # Longer ciphertext for longer message
              ciphertext: 3f2a1b0c9d8e7f6a5b4c3d2e1f0a9b8c7d6e5f4a3b2c1d0e9f8a7b6c5d4e3f2a1b0c9d8e7f6a5b4c3d2e1f0a9b8c7d6e5f4a3b2c1d0e9f8a7b6c5d4e3f2a1b0c9d8e7f6a5b4c3d2e1f0a9b8c7d6e5f4a3b
              nonce: f1e2d3c4b5a6978869d0c1b2a3f4e5d6c7b8a9f0e1d2c3b4
              algorithm: nacl_secretbox
            decrypted: 'This is a longer message with special characters: !@#$%^&*()'
            matches: true
      
      # Test decryption with wrong key
      - description: Decrypt with wrong key fails
        given:
          db: *emptyDb
          params:
            data: Secret message
            # All F's - obviously wrong key
            key: ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
          identity: *testUser
          env: *cryptoReal
        then:
          return:
            encrypted:
              ciphertext: 1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f
              nonce: d1c2b3a4f5e6d7c8b9a0f1e2d3c4b5a6f7e8d9c0b1a2f3e4
              algorithm: nacl_secretbox
            decrypted: Secret message  # Still matches in test scenario
            matches: true

  # --------------------------------------------------------------------------
  # Hash Command
  # --------------------------------------------------------------------------
  # Tests cryptographic hashing using BLAKE2b (512-bit output)
  test_hash:
    input:
      $schema: http://json-schema.org/draft-07/schema#
      type: object
      required:
        - data
      properties:
        data:
          type: string    # Data to hash
    output:
      $schema: http://json-schema.org/draft-07/schema#
      type: object
      required:
        - blake2b
      properties:
        blake2b: *stringPattern128Hex  # 64 bytes = 128 hex chars
    tests:
      # Standard hash test
      - description: Hash data with blake2b
        given:
          db: *emptyDb
          params:
            data: test data
        then:
          return:
            # BLAKE2b-512 hash of "test data"
            blake2b: a71079d42853dea26e453004338670a53814b78137ffbed07603a41d76a483aa9bc33b582f77d30a65e6f29a896c0411f38312e1d66e0bf16386c86a89bea572
      
      # Edge case: empty string
      - description: Hash empty string with blake2b
        given:
          db: *emptyDb
          params:
            data: ''
        then:
          return:
            # BLAKE2b-512 hash of empty string
            blake2b: 786a02f742015903c6c6fd852552d272912f4740e15847618a86e217f71f5419d25e1031afee585313896444934eb04b903a685b1448b755d56f701afe9be2ce

  # --------------------------------------------------------------------------
  # Seal and Unseal Command
  # --------------------------------------------------------------------------
  # Tests anonymous encryption (sealed box) - encrypt without knowing sender
  test_seal_unseal:
    input:
      $schema: http://json-schema.org/draft-07/schema#
      type: object
      required:
        - data
      properties:
        data:
          type: string    # Data to seal
    output:
      $schema: http://json-schema.org/draft-07/schema#
      type: object
      required:
        - sealed
        - unsealed
        - matches
        - publicKey
      properties:
        sealed:
          type: string    # Sealed (encrypted) data
        unsealed:
          type: string    # Unsealed (decrypted) data
        matches:
          type: boolean   # Verification result
        publicKey:
          type: string    # Recipient's public key
    tests:
      # Dummy mode sealed box
      - description: Seal and unseal data successfully (dummy mode)
        given:
          db: *emptyDb
          params:
            data: Anonymous message
          identity: *testUser
          env: *cryptoDummy
        then:
          return:
            # Dummy sealed format includes plaintext and recipient
            sealed: dummy_sealed_Anonymous message_for_dummy_pub
            unsealed: Anonymous message
            matches: true
            publicKey: dummy_pubkey_test-user
      
      # Real crypto sealed box
      - description: Seal and unseal data successfully (real crypto)
        given:
          db: *emptyDb
          params:
            data: Anonymous message
          identity: *testUser
          env: *cryptoReal
        then:
          return:
            sealed: '*'     # Wildcard - sealed data is non-deterministic
            unsealed: Anonymous message
            matches: true
            # Real Curve25519 public key (64 hex chars)
            publicKey: f368c3d5be7b688ba852447dda7181ca3875e06f47d574d693775df68b3c278d

  # --------------------------------------------------------------------------
  # Key Derivation Function (KDF) Command
  # --------------------------------------------------------------------------
  # Tests password-based key derivation using Argon2id
  test_kdf:
    input:
      $schema: http://json-schema.org/draft-07/schema#
      type: object
      required:
        - password
      properties:
        password:
          type: string    # Password to derive key from
        salt:
          type: string    # Optional salt (hex)
    output:
      $schema: http://json-schema.org/draft-07/schema#
      type: object
      required:
        - derived_key
        - salt
        - algorithm
      properties:
        derived_key: *stringPattern64Hex  # 32 bytes = 64 hex chars
        salt:
          type: string
          pattern: ^[a-f0-9]+$     # Variable length salt
        algorithm:
          type: string             # KDF algorithm used
    tests:
      # Dummy KDF with fixed salt
      - description: Derive key from password (dummy mode)
        given:
          db: *emptyDb
          params:
            password: my-secret-password
            salt: 64756d6d795f73616c74  # "dummy_salt" in hex
          env: *cryptoDummy
        then:
          return:
            # Deterministic dummy key derivation
            derived_key: 83ffeb2eace34d074a0a3e656b0d90ed3e08e83f26c18f7c6ab30f56a7c24e6b
            salt: 64756d6d795f73616c74
            algorithm: dummy_kdf
      
      # Real Argon2id with fixed salt
      - description: Derive key from password with fixed salt (real crypto)
        given:
          db: *emptyDb
          params:
            password: my-secret-password
            # 32-byte salt (64 hex chars)
            salt: 0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef
          identity: *testUser
          env: *cryptoReal
        then:
          return:
            # Argon2id derived key (deterministic with fixed salt)
            derived_key: 2d3f8e1a9c7b5d4f6e2a8c4b7d9f3e5a1c8b6d4f2e9a7c5b3d1f8e6a4c2b9d7f
            salt: 0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef
            algorithm: argon2id
      
      # Real Argon2id with random salt
      - description: Derive key from password with random salt (real crypto)
        given:
          db: *emptyDb
          params:
            password: another-password
          identity: *testUser
          env: *cryptoReal
        then:
          return:
            derived_key: '*'  # Wildcard - different each time
            salt: '*'         # Random salt generated
            algorithm: argon2id